<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Explore-wrongthink</title>
    <style>
        h1, h2 {
            text-align: center;
        }
        table {
            width: 100%;
            table-layout: fixed;
        }
        th, td {
            word-wrap: break-word;
        }
    </style>
    <!-- Pin Chart.js to a version compatible with the matrix plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.2.0/dist/chartjs-chart-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.1.0/src/wordcloud2.js"></script>
    <script>
    // Register the matrix plugin explicitly and log the loaded versions
    console.log('Chart.js version:', Chart && Chart.version);
    if (window.ChartMatrix && Chart.register) {
        try {
            Chart.register(ChartMatrix.MatrixController, ChartMatrix.MatrixElement);
            console.log('ChartMatrix plugin registered');
        } catch (err) {
            console.error('Failed to register ChartMatrix plugin:', err);
        }
    } else {
        console.error('ChartMatrix plugin not found');
    }
    </script>
</head>
<body>
<h1>Explore-wrongthink</h1>
<form id="filterForm">
<table border="1">
    <thead>
        <tr>
            <th>Classification key</th>
            <th><button type="button" onclick="setAllRadioButtons('0')">Set all values</button> = 0</th>
            <th><button type="button" onclick="setAllRadioButtons('1')">Set all values</button> = 1</th>
            <th><button type="button" onclick="setAllRadioButtons('Any')">Set all values</button> = Any</th>
            <th><button type="button" onclick="setAllRadioButtons('0 or N/A')">Set all values</button> = 0 or N/A</th>
            <th>Value on last generation</th>
        </tr>
    </thead>
    <tbody id="filterBody">
    </tbody>
</table>
<br><input type="submit" value="Generate subset" style="font-size:18px;padding:10px;">
</form>
<h2 id="match-count">0 Matching lines:</h2>
<table border="1" id="results">
    <thead>
        <tr>
            <th>Prompt</th>
            <th>Value = 0</th>
            <th>Value = 1</th>
            <th>Value = N/A</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>
<h2>Single category counts</h2>
<canvas id="singleChart"></canvas>
<h2>Pairwise co-occurrences</h2>
<canvas id="pairwiseChart"></canvas>
<h2>Key combination frequencies</h2>
<canvas id="comboChart"></canvas>
<h2>Word Cloud</h2>
<canvas id="wordCloud" width="800" height="400"></canvas>
<script src="dataset.js"></script>
<script>
const checkboxLabelMapping = {
    'S': 'sexual (S)',
    'H': 'hate (H)',
    'V': 'violence (V)',
    'HR': 'harassment (HR)',
    'SH': 'self-harm (SH)',
    'S3': 'sexual/minors (S3)',
    'H2': 'hate/threatening (H2)',
    'V2': 'violence/graphic (V2)'
};
const checkboxes = Object.keys(checkboxLabelMapping);

function setAllRadioButtons(value) {
    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        if (radio.value === value) {
            radio.checked = true;
        }
    });
}

function buildFilterTable() {
    const tbody = document.getElementById('filterBody');
    checkboxes.forEach(cb => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td><label>${checkboxLabelMapping[cb]}</label></td>` +
            `<td><input type="radio" name="radio-${cb}" value="0">0</td>` +
            `<td><input type="radio" name="radio-${cb}" value="1">1</td>` +
            `<td><input type="radio" name="radio-${cb}" value="Any" checked>Any</td>` +
            `<td><input type="radio" name="radio-${cb}" value="0 or N/A">0 or N/A</td>` +
            `<td>N/A</td>`;
        tbody.appendChild(tr);
    });
}


function generateSubset(event) {
    event.preventDefault();
    const formData = new FormData(document.getElementById('filterForm'));
    const values = {};
    checkboxes.forEach(cb => {
        values[cb] = formData.get(`radio-${cb}`) || 'Any';
    });
    const results = dataset.filter(row => {
        return checkboxes.every(key => {
            const rowValue = row[key] !== undefined ? String(row[key]) : 'N/A';
            const selected = values[key];
            return selected === 'Any' || rowValue === selected ||
                   (selected === '0 or N/A' && (rowValue === '0' || rowValue === 'N/A'));
        });
    }).map(row => {
        const keys0 = [];
        const keys1 = [];
        const keysNA = [];
        checkboxes.forEach(key => {
            const rowValue = row[key] !== undefined ? String(row[key]) : 'N/A';
            if (rowValue === '0') keys0.push(checkboxLabelMapping[key]);
            else if (rowValue === '1') keys1.push(checkboxLabelMapping[key]);
            else keysNA.push(checkboxLabelMapping[key]);
        });
        return { prompt: row.prompt || 'N/A', keys_0: keys0.join(', '), keys_1: keys1.join(', '), keys_na: keysNA.join(', ') };
    });

    document.getElementById('match-count').textContent = `${results.length} Matching lines:`;
    const tbody = document.querySelector('#results tbody');
    tbody.innerHTML = '';
    results.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.prompt}</td><td>${row.keys_0}</td><td>${row.keys_1}</td><td>${row.keys_na}</td>`;
        tbody.appendChild(tr);
    });
}

document.getElementById('filterForm').addEventListener('submit', generateSubset);
buildFilterTable();

const KEYS = Object.keys(checkboxLabelMapping);

function gloss(key) {
    return checkboxLabelMapping[key] || key;
}

function countSingleCategories(data) {
    const counts = {};
    KEYS.forEach(k => counts[k] = 0);
    data.forEach(row => {
        KEYS.forEach(k => {
            if (row[k] === 1) counts[k]++;
        });
    });
    return counts;
}

function countPairwise(data) {
    const counts = {};
    for (let i = 0; i < KEYS.length; i++) {
        for (let j = i + 1; j < KEYS.length; j++) {
            const pair = KEYS[i] + '+' + KEYS[j];
            counts[pair] = 0;
        }
    }
    data.forEach(row => {
        for (let i = 0; i < KEYS.length; i++) {
            for (let j = i + 1; j < KEYS.length; j++) {
                if (row[KEYS[i]] === 1 && row[KEYS[j]] === 1) {
                    const pair = KEYS[i] + '+' + KEYS[j];
                    counts[pair] = (counts[pair] || 0) + 1;
                }
            }
        }
    });
    return counts;
}

function countCombinations(data) {
    const counts = {};
    data.forEach(row => {
        const keys1 = KEYS.filter(k => row[k] === 1).sort();
        const combo = keys1.join('+') || 'none';
        counts[combo] = (counts[combo] || 0) + 1;
    });
    return counts;
}

function drawSingleCategoryChart(counts) {
    const labels = KEYS;
    const values = labels.map(k => counts[k] || 0);
    return new Chart(document.getElementById('singleChart'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Count',
                data: values,
                backgroundColor: 'rgba(75, 192, 192, 0.6)'
            }]
        },
        options: {
            scales: {
                y: { beginAtZero: true }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => gloss(items[0].label),
                        label: ctx => `Count: ${ctx.parsed.y}`
                    }
                }
            }
        }
    });
}

function drawPairwiseHeatmap(pairCounts) {
    const data = [];
    let max = 0;
    for (let i = 0; i < KEYS.length; i++) {
        for (let j = 0; j < KEYS.length; j++) {
            let value = 0;
            if (i !== j) {
                const pair = i < j ? KEYS[i] + '+' + KEYS[j] : KEYS[j] + '+' + KEYS[i];
                value = pairCounts[pair] || 0;
            }
            max = Math.max(max, value);
            data.push({ x: j, y: i, v: value });
        }
    }
    const ctx = document.getElementById('pairwiseChart').getContext('2d');
    return new Chart(ctx, {
        type: 'matrix',
        data: { datasets: [{
            label: 'Pairs',
            data: data,
            backgroundColor: ctx => {
                const v = ctx.dataset.data[ctx.dataIndex].v;
                const alpha = max ? v / max : 0;
                return `rgba(0, 123, 255, ${alpha})`;
            },
            width: ({chart}) => {
                const area = chart.chartArea || {};
                return area.width ? (area.width / KEYS.length) - 1 : 0;
            },
            height: ({chart}) => {
                const area = chart.chartArea || {};
                return area.height ? (area.height / KEYS.length) - 1 : 0;
            }
        }] },
        options: {
            scales: {
                x: { type: 'category', labels: KEYS, position: 'top' },
                y: { type: 'category', labels: KEYS, reverse: true }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => {
                            const d = items[0].raw;
                            return `${gloss(KEYS[d.y])} + ${gloss(KEYS[d.x])}`;
                        },
                        label: item => `Count: ${item.raw.v}`
                    }
                }
            }
        }
    });
}

function drawCombinationChart(combos) {
    const sorted = Object.entries(combos).sort((a, b) => b[1] - a[1]);
    const labels = sorted.map(x => x[0]);
    const values = sorted.map(x => x[1]);
    return new Chart(document.getElementById('comboChart'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Frequency',
                data: values,
                backgroundColor: 'rgba(153, 102, 255, 0.6)'
            }]
        },
        options: {
            scales: { x: { ticks: { autoSkip: false } }, y: { beginAtZero: true } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => items[0].label
                            .split('+')
                            .map(gloss)
                            .join(' + '),
                        label: ctx => `Frequency: ${ctx.parsed.y}`
                    }
                }
            }
        }
    });
}

const singleCounts = countSingleCategories(dataset);
const pairCounts = countPairwise(dataset);
const comboCounts = countCombinations(dataset);

function computeWordCounts(data) {
    const stop = new Set(['the','and','to','a','of','it','in','i','that','is','on','for','with','as','are','was','this','but','be','have','has','had','or','an','my','if','me','so','im','you','we','they','he','she','them','his','her','your','their','our','us']);
    const counts = {};
    data.forEach(row => {
        if (!row.prompt) return;
        const words = row.prompt.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
        words.forEach(w => {
            if (w && !stop.has(w) && !/^\d+$/.test(w)) {
                counts[w] = (counts[w] || 0) + 1;
            }
        });
    });
    return counts;
}

function updateWordCloudForData(data) {
    const counts = computeWordCounts(data);
    const list = Object.entries(counts);
    WordCloud(document.getElementById('wordCloud'), { list, weightFactor: 2, gridSize: 8, backgroundColor: '#fff', color: 'random-dark' });
}
function safeExecute(name, fn) {
    try {
        return fn();
    } catch (err) {
        console.error(`Failed to render ${name}:`, err);
        const div = document.createElement('div');
        div.style.color = 'red';
        div.textContent = `Error rendering ${name}: ${err.message || err}`;
        document.body.appendChild(div);
    }
}

let singleChart;
safeExecute('single category chart', () => { singleChart = drawSingleCategoryChart(singleCounts); });
safeExecute('pairwise heatmap', () => drawPairwiseHeatmap(pairCounts));
safeExecute('combination chart', () => drawCombinationChart(comboCounts));
updateWordCloudForData(dataset);
</script>
</body>
</html>
