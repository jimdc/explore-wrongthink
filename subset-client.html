<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Explore-wrongthink</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="static/styles.css">
    <!-- Pin Chart.js to a version compatible with the matrix plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.2.0/dist/chartjs-chart-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.1.0/src/wordcloud2.js"></script>
    <script>
    // Register the matrix plugin explicitly and log the loaded versions
    console.log('Chart.js version:', Chart && Chart.version);
    if (window.ChartMatrix && Chart.register) {
        try {
            Chart.register(ChartMatrix.MatrixController, ChartMatrix.MatrixElement);
            console.log('ChartMatrix plugin registered');
        } catch (err) {
            console.error('Failed to register ChartMatrix plugin:', err);
        }
    } else {
        console.error('ChartMatrix plugin not found');
    }
    </script>
</head>
<body>
<div id="loading"><div class="spinner"></div>Loading dataset...</div>
<div class="container my-4">
<h1>Explore-wrongthink</h1>
<form id="filterForm" class="mb-4">
<div class="table-responsive">
<table class="table table-bordered table-sm">
    <thead>
        <tr>
            <th>Classification key</th>
            <th><button type="button" onclick="setAllRadioButtons('0')">Set all values</button> = 0</th>
            <th><button type="button" onclick="setAllRadioButtons('1')">Set all values</button> = 1</th>
            <th><button type="button" onclick="setAllRadioButtons('Any')">Set all values</button> = Any</th>
            <th><button type="button" onclick="setAllRadioButtons('0 or N/A')">Set all values</button> = 0 or N/A</th>
            <th>Value on last generation</th>
        </tr>
    </thead>
    <tbody id="filterBody">
    </tbody>
</table>
</div>
<button type="submit" class="btn btn-primary my-2">Generate subset</button>
</form>
<h2 id="match-count">0 Matching lines:</h2>
<div class="table-responsive">
<table class="table table-bordered table-sm" id="results">
    <thead>
        <tr>
            <th>Prompt <small class="text-muted">(hover for classifications)</small></th>
        </tr>
    </thead>
    <tbody>
</tbody>
</table>
</div>
<div id="charts" style="display:none">
<h2>Single category counts</h2>
<canvas id="singleChart"></canvas>
<h2>Pairwise co-occurrences</h2>
<canvas id="pairwiseChart"></canvas>
<h2>Key combination frequencies</h2>
<canvas id="comboChart"></canvas>
<h2>Word Cloud</h2>
<div class="mb-2">
  <label for="wordCategorySelect" class="form-label">Word Cloud Category</label>
  <select id="wordCategorySelect" class="form-select form-select-sm w-auto"></select>
</div>
<canvas id="wordCloud"></canvas>
</div>
<script>
const checkboxLabelMapping = {
    'S': 'sexual (S)',
    'H': 'hate (H)',
    'V': 'violence (V)',
    'HR': 'harassment (HR)',
    'SH': 'self-harm (SH)',
    'S3': 'sexual/minors (S3)',
    'H2': 'hate/threatening (H2)',
    'V2': 'violence/graphic (V2)',
    'None': 'no categories flagged'
};
const checkboxes = Object.keys(checkboxLabelMapping);
const CATEGORY_KEYS = checkboxes.filter(k => k !== 'None');

function setAllRadioButtons(value) {
    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        if (radio.value === value) {
            radio.checked = true;
        }
    });
    generateSubset();
}

function buildFilterTable() {
    const tbody = document.getElementById('filterBody');
    checkboxes.forEach(cb => {
        const tr = document.createElement('tr');
        tr.innerHTML =
            `<td><label for="radio-${cb}-1" class="category-label">${checkboxLabelMapping[cb]}</label></td>` +
            `<td><input id="radio-${cb}-0" type="radio" name="radio-${cb}" value="0">0</td>` +
            `<td><input id="radio-${cb}-1" type="radio" name="radio-${cb}" value="1">1</td>` +
            `<td><input id="radio-${cb}-any" type="radio" name="radio-${cb}" value="Any" checked>Any</td>` +
            `<td><input id="radio-${cb}-na" type="radio" name="radio-${cb}" value="0 or N/A">0 or N/A</td>` +
            `<td class="last-value">N/A</td>`;
        tbody.appendChild(tr);
    });
}

function getRowValue(row, key) {
    if (key === 'None') {
        return CATEGORY_KEYS.every(k => row[k] === 0) ? '1' : '0';
    }
    return row[key] !== undefined ? String(row[key]) : 'N/A';
}


function generateSubset(event) {
    if (event) {
        event.preventDefault();
    }
    const formData = new FormData(document.getElementById('filterForm'));
    const values = {};
    checkboxes.forEach(cb => {
        values[cb] = formData.get(`radio-${cb}`) || 'Any';
    });
    const results = dataset.filter(row => {
        return checkboxes.every(key => {
            const rowValue = getRowValue(row, key);
            const selected = values[key];
            return selected === 'Any' || rowValue === selected ||
                   (selected === '0 or N/A' && (rowValue === '0' || rowValue === 'N/A'));
        });
    }).map(row => {
        const keys0 = [];
        const keys1 = [];
        const keysNA = [];
        checkboxes.forEach(key => {
            const rowValue = getRowValue(row, key);
            if (rowValue === '0') keys0.push(checkboxLabelMapping[key]);
            else if (rowValue === '1') keys1.push(checkboxLabelMapping[key]);
            else keysNA.push(checkboxLabelMapping[key]);
        });
        return { prompt: row.prompt || 'N/A', keys_0: keys0.join(', '), keys_1: keys1.join(', '), keys_na: keysNA.join(', ') };
    });

    document.getElementById('match-count').textContent = `${results.length} Matching lines:`;
    const tbody = document.querySelector('#results tbody');
    tbody.innerHTML = '';
    results.forEach(row => {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        const info = [];
        if (row.keys_1) info.push(`1: ${row.keys_1}`);
        if (row.keys_0) info.push(`0: ${row.keys_0}`);
        if (row.keys_na) info.push(`N/A: ${row.keys_na}`);
        td.textContent = row.prompt;
        if (info.length) td.title = info.join(' | ');
        tr.appendChild(td);
        tbody.appendChild(tr);
    });
}

document.getElementById('filterForm').addEventListener('submit', generateSubset);
buildFilterTable();
document.getElementById('filterForm').addEventListener('change', generateSubset);

const KEYS = CATEGORY_KEYS;

const datasetPromise = new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'dataset.js';
    script.onload = () => resolve();
    script.onerror = () => reject(new Error('Failed to load dataset.js'));
    document.head.appendChild(script);
});

function gloss(key) {
    return checkboxLabelMapping[key] || key;
}

function countSingleCategories(data) {
    const counts = {};
    KEYS.forEach(k => counts[k] = 0);
    data.forEach(row => {
        KEYS.forEach(k => {
            if (row[k] === 1) counts[k]++;
        });
    });
    return counts;
}

function countPairwise(data) {
    const counts = {};
    for (let i = 0; i < KEYS.length; i++) {
        for (let j = i + 1; j < KEYS.length; j++) {
            const pair = KEYS[i] + '+' + KEYS[j];
            counts[pair] = 0;
        }
    }
    data.forEach(row => {
        for (let i = 0; i < KEYS.length; i++) {
            for (let j = i + 1; j < KEYS.length; j++) {
                if (row[KEYS[i]] === 1 && row[KEYS[j]] === 1) {
                    const pair = KEYS[i] + '+' + KEYS[j];
                    counts[pair] = (counts[pair] || 0) + 1;
                }
            }
        }
    });
    return counts;
}

function countCombinations(data) {
    const counts = {};
    data.forEach(row => {
        const keys1 = KEYS.filter(k => row[k] === 1).sort();
        const combo = keys1.join('+') || 'none';
        counts[combo] = (counts[combo] || 0) + 1;
    });
    return counts;
}

function drawSingleCategoryChart(counts) {
    const labels = KEYS;
    const values = labels.map(k => counts[k] || 0);
    return new Chart(document.getElementById('singleChart'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Count',
                data: values,
                backgroundColor: 'rgba(75, 192, 192, 0.6)'
            }]
        },
        options: {
            scales: {
                y: { beginAtZero: true }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => gloss(items[0].label),
                        label: ctx => `Count: ${ctx.parsed.y}`
                    }
                }
            }
        }
    });
}

function drawPairwiseHeatmap(pairCounts) {
    const data = [];
    let max = 0;
    for (let i = 0; i < KEYS.length; i++) {
        for (let j = 0; j < KEYS.length; j++) {
            let value = 0;
            if (i !== j) {
                const pair = i < j ? KEYS[i] + '+' + KEYS[j] : KEYS[j] + '+' + KEYS[i];
                value = pairCounts[pair] || 0;
            }
            max = Math.max(max, value);
            data.push({ x: j, y: i, v: value });
        }
    }
    const ctx = document.getElementById('pairwiseChart').getContext('2d');
    return new Chart(ctx, {
        type: 'matrix',
        data: { datasets: [{
            label: 'Pairs',
            data: data,
            backgroundColor: ctx => {
                const v = ctx.dataset.data[ctx.dataIndex].v;
                const alpha = max ? v / max : 0;
                return `rgba(0, 123, 255, ${alpha})`;
            },
            width: ({chart}) => {
                const area = chart.chartArea || {};
                return area.width ? (area.width / KEYS.length) - 1 : 0;
            },
            height: ({chart}) => {
                const area = chart.chartArea || {};
                return area.height ? (area.height / KEYS.length) - 1 : 0;
            }
        }] },
        options: {
            scales: {
                x: { type: 'category', labels: KEYS, position: 'top' },
                y: { type: 'category', labels: KEYS, reverse: true }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => {
                            const d = items[0].raw;
                            return `${gloss(KEYS[d.y])} + ${gloss(KEYS[d.x])}`;
                        },
                        label: item => `Count: ${item.raw.v}`
                    }
                }
            }
        }
    });
}

function drawCombinationChart(combos) {
    const sorted = Object.entries(combos).sort((a, b) => b[1] - a[1]);
    const labels = sorted.map(x => x[0]);
    const values = sorted.map(x => x[1]);
    return new Chart(document.getElementById('comboChart'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Frequency',
                data: values,
                backgroundColor: 'rgba(153, 102, 255, 0.6)'
            }]
        },
        options: {
            scales: { x: { ticks: { autoSkip: false } }, y: { beginAtZero: true } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => items[0].label
                            .split('+')
                            .map(gloss)
                            .join(' + '),
                        label: ctx => `Frequency: ${ctx.parsed.y}`
                    }
                }
            }
        }
    });
}


const defaultStopWords = [
  'the','and','to','a','of','it','in','i','that','is','on','for','with','as','are','was',
  'this','but','be','have','has','had','or','an','my','if','me','so','im','you','we',
  'they','he','she','them','his','her','your','their','our','us','do','does','did',
  'at','by','from','here','there','what','who','whom','which','where','when','why',
  'how','can','could','should','would','shall','will','just','dont','didnt','cant',
  'wont','about','up','down','out','over','again','more','some','no','yes','not',
  'very','into','because','also','s','t','m','d','ll','ve','re','person','organization'
];
const stopWords = new Set(defaultStopWords);
let precomputedWordCounts = {};

function buildDynamicStopWords(data, topN = 50) {
    const counts = {};
    data.forEach(row => {
        if (!row.prompt) return;
        const words = row.prompt.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
        words.forEach(w => {
            if (w && !defaultStopWords.includes(w) && !/^\d+$/.test(w)) {
                counts[w] = (counts[w] || 0) + 1;
            }
        });
    });
    const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, topN);
    sorted.forEach(([w]) => stopWords.add(w));
}

function computeWordCounts(data) {
    const counts = {};
    data.forEach(row => {
        if (!row.prompt) return;
        const words = row.prompt.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
        words.forEach(w => {
            if (w && !stopWords.has(w) && !/^\d+$/.test(w)) {
                counts[w] = (counts[w] || 0) + 1;
            }
        });
    });
    return counts;
}

function precomputeWordCountsByCategory(data) {
    const result = { All: {} };
    KEYS.forEach(k => result[k] = {});
    data.forEach(row => {
        if (!row.prompt) return;
        const words = row.prompt.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
        words.forEach(w => {
            if (!w || stopWords.has(w) || /^\d+$/.test(w)) return;
            result.All[w] = (result.All[w] || 0) + 1;
            KEYS.forEach(k => {
                if (row[k] === 1) {
                    const counts = result[k];
                    counts[w] = (counts[w] || 0) + 1;
                }
            });
        });
    });
    return result;
}

function updateWordCloudForCategory(cat) {
    const counts = precomputedWordCounts[cat] || {};
    const list = Object.entries(counts);
    WordCloud(document.getElementById('wordCloud'), { list, weightFactor: 2, gridSize: 8, backgroundColor: '#fff', color: 'random-dark' });
}

function buildWordCloudSelector() {
    const sel = document.getElementById('wordCategorySelect');
    sel.innerHTML = '';
    const allOpt = document.createElement('option');
    allOpt.value = 'All';
    allOpt.textContent = 'All';
    sel.appendChild(allOpt);
    KEYS.forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = gloss(k);
        sel.appendChild(opt);
    });
    sel.addEventListener('change', () => updateWordCloudForCategory(sel.value));
}
function safeExecute(name, fn) {
    try {
        return fn();
    } catch (err) {
        console.error(`Failed to render ${name}:`, err);
        const div = document.createElement('div');
        div.style.color = 'red';
        div.textContent = `Error rendering ${name}: ${err.message || err}`;
        document.body.appendChild(div);
    }
}

let singleChart;

datasetPromise.then(() => {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('charts').style.display = 'block';
    buildDynamicStopWords(dataset);
    precomputedWordCounts = precomputeWordCountsByCategory(dataset);
    buildWordCloudSelector();
    const singleCounts = countSingleCategories(dataset);
    const pairCounts = countPairwise(dataset);
    const comboCounts = countCombinations(dataset);
    safeExecute('single category chart', () => { singleChart = drawSingleCategoryChart(singleCounts); });
    safeExecute('pairwise heatmap', () => drawPairwiseHeatmap(pairCounts));
    safeExecute('combination chart', () => drawCombinationChart(comboCounts));
    updateWordCloudForCategory('All');
    generateSubset();
}).catch(err => {
    const loading = document.getElementById('loading');
    if (loading) loading.textContent = 'Error loading dataset: ' + (err.message || err);
    console.error('Failed to load dataset.js', err);
});
</script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('service-worker.js');
  });
}
</script>
</body>
</html>
